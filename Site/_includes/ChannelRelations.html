

<script src="https://d3js.org/d3.v5.js"></script>

<style>
    #viz {
        width: 100vw;
        height: 90vh;
    }

    .link {
        stroke: #aaa;
        opacity: 0.2;
    }

    .node text {
        stroke: #333;
        font-size: 0.7em;
    }

    .node circle {
        stroke: #fff;
        fill: #333;
        stroke-width: 3px;
    }
</style>


<svg id='viz'></svg>

    

<script>
    var linkOpacity = 0.3;

    const vizEl = document.getElementById('viz');
    const rect = vizEl.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;

    loadChart();

    async function loadChart() {
        const channels = await d3.csv("https://raw.githubusercontent.com/markledwich2/YouTubeNetworks/master/Data/3.Vis/Channels.csv");
        const recommends = await d3.csv("https://raw.githubusercontent.com/markledwich2/YouTubeNetworks/master/Data/3.Vis/ChannelRelations.csv");
        const links = recommends.map(d => new Link(d.FromChannelTitle, d.ChannelTitle, d.Size));
        const nodes = channels.map(d => new Node(d.title, d.subCount))

        const force = d3.forceSimulation(nodes)
        .force("charge", d3.forceManyBody().strength(-3000))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("x", d3.forceX(width / 2).strength(1))
        .force("y", d3.forceY(height / 2).strength(1))
        .force("link", d3.forceLink(links).id(function(d) {return d.id; }).distance(50).strength(1))
        .on("tick", () => {
            node.call(updateNode);
            link.call(updateLink);
        });
        /*for (i = 0; i < 200; i++)
            force.tick();*/

        var adjlist = ~[];
        channels.forEach(d => {
            adjlist[d.source.index + "-" + d.target.index] = true;
            adjlist[d.target.index + "-" + d.source.index] = true;
        });

        function neigh(a, b) {
            return a == b || adjlist[a + "-" + b];
        }

        const svg = d3.select("#viz")
            .attr("viewBox", [-width / 2, -height / 2, width, height]);

        var container = svg.append("g");

        svg.call(
            d3.zoom()
                .scaleExtent([.1, 4])
                .on("zoom", () => container.attr("transform", d3.event.transform))
        );

        var link = container.append("g").attr("class", "links")
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr("class", "link");

        var node = container.append("g").attr("class", "nodes")
            .selectAll("g")
            .data(nodes)
            .enter().append("g")
            .attr("class", "node");

        node.append("circle")
            .attr("r", 5)
        //.attr("fill", function (d) { return color(d.group); })

        node.append("text")
            .attr("dx", 12)
            .attr("dy", ".35em")
            .text(d => d.id);

        node.on("mouseover", focus).on("mouseout", unfocus);

        function focus(d) {
            var index = d3.select(d3.event.target).datum().index;
            node.style("opacity", function (o) {
                return neigh(index, o.index) ? 1 : 0.1;
            });
            link.style("opacity", function (o) {
                return o.source.index == index || o.target.index == index ? linkOpacity : 0.1;
            });
        }

        function unfocus() {
            node.style("opacity", 1);
            link.style("opacity", linkOpacity);
        }

        function fixna(x) {
            if (isFinite(x)) return x;
            return 0;
        }

        function updateLink(link) {
            link.attr("x1", function (d) { return fixna(d.source.x); })
                .attr("y1", function (d) { return fixna(d.source.y); })
                .attr("x2", function (d) { return fixna(d.target.x); })
                .attr("y2", function (d) { return fixna(d.target.y); });
        }

        function updateNode(node) {
            node.attr("transform", function (d) {
                return "translate(" + fixna(d.x) + "," + fixna(d.y) + ")";
            });
        }
    }

    class Link {
        constructor(source, target, size) {
            this.source = source;
            this.target = target;
            this.size = size;
        }
    }

    class Node {
        constructor(id, title, subs) {
            this.id = id;
            this.title = title;
            this.subs = subs;
        }
    }

</script>